( function(){

    $(function(){


	    $("a.zayavka").click(function () {
	        var elementClick = $(this).attr("href")
	        var destination = $(elementClick).offset().top;
	        jQuery("html:not(:animated),body:not(:animated)").animate({scrollTop: destination}, 800);
	        return false;
	    });
	    
	    
		$('.fancybox').fancybox({
			'padding': 0
		});

	    $("a.close2").click(function(){
		    $.fancybox.close(); 
		    return false; 
	    })
	    
	    $("a.close").click(function(){
		    $(".call_back").slideUp();	
		    return false; 
	    })
	    $(".site__header-recall").click(function(){
		    $(".call_back").slideToggle();	
		    $(".ok3").hide();
		    return false;
	    })

        if($( '.ares-slider').length){
            $( '.ares-slider').each( function(){

                new AresSlider1( {
                    obj: $(this),
                    items: $(this).find( '.ares-slider__item' ),
                    btnNext: $(this).find( '.ares-slider__next' ),
                    btnPrev: $(this).find('.ares-slider__prev')
                } );
            } );
        }

        $( '.contacts__map' ).each( function(){
            new Map( $( this ) );
        } );

        $.each( $('.slider'), function () {
            var curItem = $( this );

            new SliderSingle( {
                obj: curItem,
                wrap: curItem.find( '.slider__wrap' ),
                slides: curItem.find( '.slider__item'),
                duration: 300,
                delay: 3000
            } );
        });
    });

    var Map = function (obj) {

        var _self = this,
            _obj = obj,
            _data = obj.data('map'),
            _map = null;

        var _addMap = function () {
                var mapOptions = {
                    zoom: _data.zoom,
                    center: new google.maps.LatLng(_data.center[0], _data.center[1])
                };


                _map = new google.maps.Map(obj[0],mapOptions);

                _setMarkers();
            },

            _init = function () {
                google.maps.event.addDomListener(window, 'load', _addMap);
            },
            _setMarkers = function () {
                var image = {
                    url: 'img/mapicon.png',
                    size: new google.maps.Size(26, 40),
                    origin: new google.maps.Point(0,0),
                    anchor: new google.maps.Point(10, 38)
                };
                for (var i = 0; i < _data.points.length; i++) {
                    var beach = _data.points[i];
                    var myLatLng = new google.maps.LatLng(beach.center[0], beach.center[1]);
                    var marker = new google.maps.Marker({
                        position: myLatLng,
                        map: _map,
                        icon: image,
                        title: beach.title,
                        zIndex: 5
                    });
                }
            };

        _init();
    };

    var AresSlider1 = function( params ){
        this.obj = params.obj;
        this.elems = {
            btnPrev: params.btnPrev,
            btnNext: params.btnNext,
            items: params.items
        };
        this.action = false;
        this.duration = params.duration || 10000;

        this.init();
    };
    AresSlider1.prototype = {
        init: function(){
            var self = this;

            self.core = self.core();
            self.core.build();
        },
        core: function(){
            var self = this,
                elems = self.elems;

            return {
                build: function(){
                    var count = elems.items.length,
                        i,
                        points = $( '<ul class="ares-slider__points"></ul>' );
                    if ( self.obj.hasClass('ares-slider_preview') ){
                        points = self.obj.find('.assortment__preview');
                    }
                    if ( self.elems.items.length>1 ){
                        if ( !self.obj.hasClass('ares-slider_preview') ){
                            for( i = 0; i < count; i++ ){
                                points.append( '<li></li>' );
                            }
                            self.obj.append( points );
                        }
                        elems.points = points.find( 'li' );
                        elems.points.eq( 0 ).addClass( 'active' );
                        elems.items.eq( 0 ).css( { display: 'block' } );
                        self.core.controls();
                        self.core.slideToNext();
                    } else {
                        self.elems.btnNext.remove();
                        self.elems.btnPrev.remove();
                    }

                },

                slideToNext: function(){
                    self.timer = setTimeout( function(){
                        elems.btnNext.trigger( 'click' );
                    }, self.duration );
                },
                controls: function(){
                    elems.btnPrev.on( {
                        'click': function(){
                            var index = ( ( elems.points.filter( '.active' ).index() - 1 ) == -1 ) ? (elems.points.length - 1) :( elems.points.filter( '.active' ).index() - 1 );

                            self.slideTo( index );
                        }
                    } );
                    elems.btnNext.on( {
                        'click': function(){
                            var index = ( ( elems.points.filter( '.active' ).index() + 1 ) == elems.points.length )? 0:( elems.points.filter( '.active' ).index() + 1 );

                            self.slideTo( index );
                        }
                    } );
                    elems.points.on( {
                        'click': function(){
                            var curItem = $( this );

                            if( !curItem.hasClass( 'active' ) ){
                                self.slideTo( curItem.index() );
                            }
                        }
                    } );
                    self.obj.on( {
                        'mouseover': function(){
                            clearTimeout( self.timer );
                        },
                        'mouseleave': function(){
                            self.core.slideToNext();
                        }
                    } );
                }
            };
        },
        slideTo: function( index ) {
            var self = this,
                elems = self.elems,
                activeIndex = elems.points.filter( '.active' ).index(),
                direction,
                curW = self.obj.width(),
                activeItem = elems.items.eq( activeIndex ),
                activePoint = elems.points.eq( activeIndex ),
                newItem = elems.items.eq( index),
                newPoint = elems.points.eq( index );

            clearTimeout( self.timer );
            if( !self.action ){
                self.action = true;

                if( activeIndex < index ){
                    direction = 1;
                } else {
                    direction = -1;
                }

                if( activeIndex == 0 && index == ( elems.points.length - 1 ) ){
                    direction = -1;
                } else if ( activeIndex == ( elems.points.length - 1 )  && index == 0 ){
                    direction = 1;
                }

                activePoint.removeClass( 'active' );
                newPoint.addClass( 'active' );

                newItem.css( {
                    display: 'block',
                    left: curW * -direction,
                    opacity: 0
                } );
                activeItem.animate( {
                    left: curW * direction,
                    opacity: 0
                }, 300, function() {
                    $( this ).css( { display: 'none' } );
                    self.action = false;
                    self.core.slideToNext();
                } );
                newItem.animate( {
                    left: 0,
                    opacity: 1
                }, 300 );
            }

        }
    };

    var SliderSingle = function (params) {
        this.obj = params.obj;
        this.slides = params.slides;
        this.wrap = params.wrap;
        this.duration = params.duration || 300;
        this.delay = params.delay || 5000;
        this.easing = params.easing || 'linear';
        this.action = false;
        this.timer = setTimeout(function () {
        }, 1);
        this.window = $(window);
        this.videoLink = $('.video-card__lnk');

        this.init();
    };
    SliderSingle.prototype = {
        init: function () {
            var self = this;

            self.core = self.core();
            self.core.build();
        },
        core: function () {
            var self = this;

            return {
                addEvents: function () {
                    var hammer = new Hammer(self.wrap[0]);

                    hammer.on('pan panend', function (e) {
                        if (!self.action) {
                            var delta = e.deltaX;

                            self.core.moveSlide(delta);

                            if (e.type == 'panend') {
                                if (delta > 0) {
                                    self.core.slideToPrev(delta);
                                } else if (delta < 0) {
                                    self.core.slideToNext(delta);
                                }
                            }
                        }
                    });

                    self.wrap.on({
                        mousemove: function () {
                            clearTimeout(self.timer);
                        },
                        mouseleave: function () {
                            self.core.autoSlide();
                        }
                    });

                    self.window.on({
                        resize: function () {
                            self.core.getSlideSize();

                            self.slides.css({ left: self.width });
                            self.slides.eq( self.active ).css({ left: 0 });
                        }
                    });

                    self.btnNext.on({
                        click: function () {
                            if (!self.action) {
                                self.core.slideTo(self.active + 1, 1);
                            }

                            return false;
                        }
                    });
                    self.btnPrev.on({
                        click: function () {
                            if (!self.action) {
                                self.core.slideTo((self.active - 1), -1);
                            }

                            return false;
                        }
                    });
                    self.points.on({
                        click: function () {
                            var curPoint = $(this);

                            if (!curPoint.hasClass('active') && !self.action) {
                                self.core.slideTo(curPoint.index());
                                self.points.removeClass('active');
                                curPoint.addClass('active');
                            }


                            return false;
                        }
                    });

                    self.videoLink.on( {
                        click: function(){
                            var parent = $(this).parents( '.slider' );

                            clearTimeout( self.timer );
                            parent.append('<div class="slider__video">\
                                <button class="slider__close">×</button>\
                                <iframe width="100%" height="100%" src="'+$(this).attr('data-video')+'" frameborder="0" allowfullscreen></iframe>\
                            </div>');

                            $( '.slider__close').on( {
                                click: function(){
                                    $( '.slider__close').parent().remove();
                                }
                            } );


                            return false;
                        }
                    } );
                },
                addControls: function () {
                    var pointsWrap = $('<ul class="' + self.className + '__points"/>');
                    self.btnPrev = $('<div class="' + self.className + '__btn ' + self.className + '__btn_prev glyphicon glyphicon-chevron-left"></div>');
                    self.btnNext = $('<div class="' + self.className + '__btn ' + self.className + '__btn_next glyphicon glyphicon-chevron-right"></div>');


                    $.each(self.slides, function () {
                        var data = $( this ).data('point');

                        pointsWrap.append('<li><div><span>'+data.title+'</span> '+data.text+'</div></li>');

                    });
                    self.points = pointsWrap.find('li');
                    self.points.eq(self.active).addClass('active');

                    self.obj.append(self.btnPrev);
                    self.obj.append(self.btnNext);
                    self.obj.prepend(pointsWrap);

                },
                autoSlide: function () {
                   // self.timer = setTimeout(function () {
                     //   self.btnNext.trigger('click');
                    //}, self.delay);
                },
                build: function () {
                    self.core.startView();
                },
                destroy: function () {
                    self.slides.removeAttr('style');
                    self.btnNext.remove();
                    self.btnPrev.remove();

                    self = null;
                },
                getSlideSize: function () {
                    self.width = self.wrap.width();
                    self.height = self.wrap.height();
                },
                moveSlide: function (delta) {
                    self.slides.css({
                        left: self.width
                    });

                    clearTimeout(self.timer);

                    var curSlide = self.slides.eq(self.active),
                        secondSlide;

                    if (delta > 0) {
                        secondSlide = self.slides.eq(self.active - 1);
                        secondSlide.css({
                            left: -self.width + delta
                        });
                    } else {
                        secondSlide = self.slides.eq(self.active + 1);

                        if (!secondSlide.length) {
                            secondSlide = self.slides.eq(0);
                        }
                        secondSlide.css({
                            left: self.width + delta
                        });
                    }

                    curSlide.css({
                        left: delta
                    });

                    self.core.autoSlide();


                },
                slideTo: function (index, direction) {
                    var newIndex = index,
                        nextItem = null,
                        activeItem = self.slides.eq(self.active),
                        direction = direction || undefined,
                        count1 = 0,
                        count2 = 0;

                    if (direction == -1) {
                        direction = 0;
                    }

                    clearTimeout(self.timer);
                    self.action = true;



                    if (index < 0) {
                        newIndex = self.slides.length - 1;
                    } else if (index == self.slides.length) {
                        newIndex = 0;
                    }

                    nextItem = self.slides.eq(newIndex);

                    count1 = Math.abs(newIndex - self.active);

                    if (direction === undefined) {
                        direction = ( newIndex > self.active );

                        if (newIndex > self.active) {
                            count2 = ( self.slides.length - newIndex ) + ( self.active - 1 );

                            if (count1 > count2) {
                                direction = 0;
                            } else if (count1 < count2) {
                                direction = 1;
                            }
                        } else {
                            count2 = ( self.slides.length - self.active ) + ( newIndex - 1 );

                            if (count1 > count2) {
                                direction = 1;
                            } else if (count1 < count2) {
                                direction = 0;
                            }
                        }
                    }



                    if (direction) {
                        nextItem.css({
                            left: self.width
                        });
                    } else {
                        nextItem.css({
                            left: -self.width
                        });
                    }
                    self.points.removeClass('active');
                    self.points.eq(newIndex).addClass('active');


                    setTimeout(function () {
                        self.wrap.addClass('animated');
                        nextItem.css({
                            left: 0
                        });

                        if (direction) {
                            activeItem.css({
                                left: -self.width
                            });
                        } else {
                            activeItem.css({
                                left: self.width
                            });
                        }
                        setTimeout(function () {
                            self.action = false;
                            self.active = newIndex;
                            self.wrap.removeClass('animated');
                            self.core.autoSlide();
                        }, self.duration + 1);
                    }, 50);

                },
                slideToNext: function (delta) {
                    var curSlide = self.slides.eq(self.active),
                        secondSlide = self.slides.eq(self.active + 1);

                    clearTimeout(self.timer);

                    self.action = true;
                    self.wrap.addClass('animated');

                    if (!secondSlide.length) {
                        secondSlide = self.slides.eq(0);
                    }

                    if (( Math.abs(delta) / self.width ) > 0.2) {
                        curSlide.css({
                            left: -self.width
                        });
                        secondSlide.css({
                            left: 0
                        });
                        self.active = secondSlide.index();
                        self.points.removeClass('active');
                        self.points.eq(self.active).addClass('active');
                    } else {
                        curSlide.css({
                            left: 0
                        });
                        secondSlide.css({
                            left: self.width
                        });
                    }
                    setTimeout(function () {
                        self.wrap.removeClass('animated');
                        self.action = false;
                        self.core.autoSlide();
                    }, self.duration);
                },
                slideToPrev: function (delta) {
                    var curSlide = self.slides.eq(self.active),
                        secondSlide = self.slides.eq(self.active - 1);

                    clearTimeout(self.timer);

                    self.action = true;
                    self.wrap.addClass('animated');

                    if (( Math.abs(delta) / self.width ) > 0.2) {
                        curSlide.css({
                            left: self.width
                        });
                        secondSlide.css({
                            left: 0
                        });
                        self.active = secondSlide.index();
                        self.points.removeClass('active');
                        self.points.eq(self.active).addClass('active');
                    } else {
                        curSlide.css({
                            left: 0
                        });
                        secondSlide.css({
                            left: -self.width
                        });
                    }
                    setTimeout(function () {
                        self.wrap.removeClass('animated');
                        self.action = false;
                        self.core.autoSlide();
                    }, self.duration);
                },
                startView: function () {
                    if (self.slides.length > 1) {

                        self.className = self.obj.attr('class').split(' ')[0];
                        self.core.getSlideSize();
                        self.active = 0;

                        self.slides.css({
                            left: self.width
                        });

                        self.slides.eq(self.active).css({
                            left: 0
                        });

                        self.core.addControls();

                        self.core.addEvents();
                        self.core.autoSlide();
                    }
                }
            };
        }
    };
} )();

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) {
    "use strict";
    function e(a, b, c) {
        return setTimeout(k(a, c), b)
    }

    function f(a, b, c) {
        return Array.isArray(a) ? (g(a, c[b], c), !0) : !1
    }

    function g(a, b, c) {
        var e;
        if (a)if (a.forEach)a.forEach(b, c); else if (a.length !== d)for (e = 0; e < a.length;)b.call(c, a[e], e, a), e++; else for (e in a)a.hasOwnProperty(e) && b.call(c, a[e], e, a)
    }

    function h(a, b, c) {
        for (var e = Object.keys(b), f = 0; f < e.length;)(!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
        return a
    }

    function i(a, b) {
        return h(a, b, !0)
    }

    function j(a, b, c) {
        var d, e = b.prototype;
        d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && h(d, c)
    }

    function k(a, b) {
        return function () {
            return a.apply(b, arguments)
        }
    }

    function l(a, b) {
        return typeof a == kb ? a.apply(b ? b[0] || d : d, b) : a
    }

    function m(a, b) {
        return a === d ? b : a
    }

    function n(a, b, c) {
        g(r(b), function (b) {
            a.addEventListener(b, c, !1)
        })
    }

    function o(a, b, c) {
        g(r(b), function (b) {
            a.removeEventListener(b, c, !1)
        })
    }

    function p(a, b) {
        for (; a;) {
            if (a == b)return !0;
            a = a.parentNode
        }
        return !1
    }

    function q(a, b) {
        return a.indexOf(b) > -1
    }

    function r(a) {
        return a.trim().split(/\s+/g)
    }

    function s(a, b, c) {
        if (a.indexOf && !c)return a.indexOf(b);
        for (var d = 0; d < a.length;) {
            if (c && a[d][c] == b || !c && a[d] === b)return d;
            d++
        }
        return -1
    }

    function t(a) {
        return Array.prototype.slice.call(a, 0)
    }

    function u(a, b, c) {
        for (var d = [], e = [], f = 0; f < a.length;) {
            var g = b ? a[f][b] : a[f];
            s(e, g) < 0 && d.push(a[f]), e[f] = g, f++
        }
        return c && (d = b ? d.sort(function (a, c) {
            return a[b] > c[b]
        }) : d.sort()), d
    }

    function v(a, b) {
        for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ib.length;) {
            if (c = ib[g], e = c ? c + f : b, e in a)return e;
            g++
        }
        return d
    }

    function w() {
        return ob++
    }

    function x(a) {
        var b = a.ownerDocument;
        return b.defaultView || b.parentWindow
    }

    function y(a, b) {
        var c = this;
        this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {
            l(a.options.enable, [a]) && c.handler(b)
        }, this.init()
    }

    function z(a) {
        var b, c = a.options.inputClass;
        return new (b = c ? c : rb ? N : sb ? Q : qb ? S : M)(a, A)
    }

    function A(a, b, c) {
        var d = c.pointers.length, e = c.changedPointers.length, f = b & yb && d - e === 0, g = b & (Ab | Bb) && d - e === 0;
        c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, B(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c
    }

    function B(a, b) {
        var c = a.session, d = b.pointers, e = d.length;
        c.firstInput || (c.firstInput = E(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = E(b) : 1 === e && (c.firstMultiple = !1);
        var f = c.firstInput, g = c.firstMultiple, h = g ? g.center : f.center, i = b.center = F(d);
        b.timeStamp = nb(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = J(h, i), b.distance = I(h, i), C(c, b), b.offsetDirection = H(b.deltaX, b.deltaY), b.scale = g ? L(g.pointers, d) : 1, b.rotation = g ? K(g.pointers, d) : 0, D(c, b);
        var j = a.element;
        p(b.srcEvent.target, j) && (j = b.srcEvent.target), b.target = j
    }

    function C(a, b) {
        var c = b.center, d = a.offsetDelta || {}, e = a.prevDelta || {}, f = a.prevInput || {};
        (b.eventType === yb || f.eventType === Ab) && (e = a.prevDelta = {
            x: f.deltaX || 0,
            y: f.deltaY || 0
        }, d = a.offsetDelta = {x: c.x, y: c.y}), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y)
    }

    function D(a, b) {
        var c, e, f, g, h = a.lastInterval || b, i = b.timeStamp - h.timeStamp;
        if (b.eventType != Bb && (i > xb || h.velocity === d)) {
            var j = h.deltaX - b.deltaX, k = h.deltaY - b.deltaY, l = G(i, j, k);
            e = l.x, f = l.y, c = mb(l.x) > mb(l.y) ? l.x : l.y, g = H(j, k), a.lastInterval = b
        } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;
        b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g
    }

    function E(a) {
        for (var b = [], c = 0; c < a.pointers.length;)b[c] = {
            clientX: lb(a.pointers[c].clientX),
            clientY: lb(a.pointers[c].clientY)
        }, c++;
        return {timeStamp: nb(), pointers: b, center: F(b), deltaX: a.deltaX, deltaY: a.deltaY}
    }

    function F(a) {
        var b = a.length;
        if (1 === b)return {x: lb(a[0].clientX), y: lb(a[0].clientY)};
        for (var c = 0, d = 0, e = 0; b > e;)c += a[e].clientX, d += a[e].clientY, e++;
        return {x: lb(c / b), y: lb(d / b)}
    }

    function G(a, b, c) {
        return {x: b / a || 0, y: c / a || 0}
    }

    function H(a, b) {
        return a === b ? Cb : mb(a) >= mb(b) ? a > 0 ? Db : Eb : b > 0 ? Fb : Gb
    }

    function I(a, b, c) {
        c || (c = Kb);
        var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]];
        return Math.sqrt(d * d + e * e)
    }

    function J(a, b, c) {
        c || (c = Kb);
        var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]];
        return 180 * Math.atan2(e, d) / Math.PI
    }

    function K(a, b) {
        return J(b[1], b[0], Lb) - J(a[1], a[0], Lb)
    }

    function L(a, b) {
        return I(b[0], b[1], Lb) / I(a[0], a[1], Lb)
    }

    function M() {
        this.evEl = Nb, this.evWin = Ob, this.allow = !0, this.pressed = !1, y.apply(this, arguments)
    }

    function N() {
        this.evEl = Rb, this.evWin = Sb, y.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
    }

    function O() {
        this.evTarget = Ub, this.evWin = Vb, this.started = !1, y.apply(this, arguments)
    }

    function P(a, b) {
        var c = t(a.touches), d = t(a.changedTouches);
        return b & (Ab | Bb) && (c = u(c.concat(d), "identifier", !0)), [c, d]
    }

    function Q() {
        this.evTarget = Xb, this.targetIds = {}, y.apply(this, arguments)
    }

    function R(a, b) {
        var c = t(a.touches), d = this.targetIds;
        if (b & (yb | zb) && 1 === c.length)return d[c[0].identifier] = !0, [c, c];
        var e, f, g = t(a.changedTouches), h = [], i = this.target;
        if (f = c.filter(function (a) {
                return p(a.target, i)
            }), b === yb)for (e = 0; e < f.length;)d[f[e].identifier] = !0, e++;
        for (e = 0; e < g.length;)d[g[e].identifier] && h.push(g[e]), b & (Ab | Bb) && delete d[g[e].identifier], e++;
        return h.length ? [u(f.concat(h), "identifier", !0), h] : void 0
    }

    function S() {
        y.apply(this, arguments);
        var a = k(this.handler, this);
        this.touch = new Q(this.manager, a), this.mouse = new M(this.manager, a)
    }

    function T(a, b) {
        this.manager = a, this.set(b)
    }

    function U(a) {
        if (q(a, bc))return bc;
        var b = q(a, cc), c = q(a, dc);
        return b && c ? cc + " " + dc : b || c ? b ? cc : dc : q(a, ac) ? ac : _b
    }

    function V(a) {
        this.id = w(), this.manager = null, this.options = i(a || {}, this.defaults), this.options.enable = m(this.options.enable, !0), this.state = ec, this.simultaneous = {}, this.requireFail = []
    }

    function W(a) {
        return a & jc ? "cancel" : a & hc ? "end" : a & gc ? "move" : a & fc ? "start" : ""
    }

    function X(a) {
        return a == Gb ? "down" : a == Fb ? "up" : a == Db ? "left" : a == Eb ? "right" : ""
    }

    function Y(a, b) {
        var c = b.manager;
        return c ? c.get(a) : a
    }

    function Z() {
        V.apply(this, arguments)
    }

    function $() {
        Z.apply(this, arguments), this.pX = null, this.pY = null
    }

    function _() {
        Z.apply(this, arguments)
    }

    function ab() {
        V.apply(this, arguments), this._timer = null, this._input = null
    }

    function bb() {
        Z.apply(this, arguments)
    }

    function cb() {
        Z.apply(this, arguments)
    }

    function db() {
        V.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
    }

    function eb(a, b) {
        return b = b || {}, b.recognizers = m(b.recognizers, eb.defaults.preset), new fb(a, b)
    }

    function fb(a, b) {
        b = b || {}, this.options = i(b, eb.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = z(this), this.touchAction = new T(this, this.options.touchAction), gb(this, !0), g(b.recognizers, function (a) {
            var b = this.add(new a[0](a[1]));
            a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3])
        }, this)
    }

    function gb(a, b) {
        var c = a.element;
        g(a.options.cssProps, function (a, d) {
            c.style[v(c.style, d)] = b ? a : ""
        })
    }

    function hb(a, c) {
        var d = b.createEvent("Event");
        d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d)
    }

    var ib = ["", "webkit", "moz", "MS", "ms", "o"], jb = b.createElement("div"), kb = "function", lb = Math.round, mb = Math.abs, nb = Date.now, ob = 1, pb = /mobile|tablet|ip(ad|hone|od)|android/i, qb = "ontouchstart"in a, rb = v(a, "PointerEvent") !== d, sb = qb && pb.test(navigator.userAgent), tb = "touch", ub = "pen", vb = "mouse", wb = "kinect", xb = 25, yb = 1, zb = 2, Ab = 4, Bb = 8, Cb = 1, Db = 2, Eb = 4, Fb = 8, Gb = 16, Hb = Db | Eb, Ib = Fb | Gb, Jb = Hb | Ib, Kb = ["x", "y"], Lb = ["clientX", "clientY"];
    y.prototype = {
        handler: function () {
        }, init: function () {
            this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(x(this.element), this.evWin, this.domHandler)
        }, destroy: function () {
            this.evEl && o(this.element, this.evEl, this.domHandler), this.evTarget && o(this.target, this.evTarget, this.domHandler), this.evWin && o(x(this.element), this.evWin, this.domHandler)
        }
    };
    var Mb = {mousedown: yb, mousemove: zb, mouseup: Ab}, Nb = "mousedown", Ob = "mousemove mouseup";
    j(M, y, {
        handler: function (a) {
            var b = Mb[a.type];
            b & yb && 0 === a.button && (this.pressed = !0), b & zb && 1 !== a.which && (b = Ab), this.pressed && this.allow && (b & Ab && (this.pressed = !1), this.callback(this.manager, b, {
                pointers: [a],
                changedPointers: [a],
                pointerType: vb,
                srcEvent: a
            }))
        }
    });
    var Pb = {pointerdown: yb, pointermove: zb, pointerup: Ab, pointercancel: Bb, pointerout: Bb}, Qb = {
        2: tb,
        3: ub,
        4: vb,
        5: wb
    }, Rb = "pointerdown", Sb = "pointermove pointerup pointercancel";
    a.MSPointerEvent && (Rb = "MSPointerDown", Sb = "MSPointerMove MSPointerUp MSPointerCancel"), j(N, y, {
        handler: function (a) {
            var b = this.store, c = !1, d = a.type.toLowerCase().replace("ms", ""), e = Pb[d], f = Qb[a.pointerType] || a.pointerType, g = f == tb, h = s(b, a.pointerId, "pointerId");
            e & yb && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ab | Bb) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {
                pointers: b,
                changedPointers: [a],
                pointerType: f,
                srcEvent: a
            }), c && b.splice(h, 1))
        }
    });
    var Tb = {
        touchstart: yb,
        touchmove: zb,
        touchend: Ab,
        touchcancel: Bb
    }, Ub = "touchstart", Vb = "touchstart touchmove touchend touchcancel";
    j(O, y, {
        handler: function (a) {
            var b = Tb[a.type];
            if (b === yb && (this.started = !0), this.started) {
                var c = P.call(this, a, b);
                b & (Ab | Bb) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {
                    pointers: c[0],
                    changedPointers: c[1],
                    pointerType: tb,
                    srcEvent: a
                })
            }
        }
    });
    var Wb = {
        touchstart: yb,
        touchmove: zb,
        touchend: Ab,
        touchcancel: Bb
    }, Xb = "touchstart touchmove touchend touchcancel";
    j(Q, y, {
        handler: function (a) {
            var b = Wb[a.type], c = R.call(this, a, b);
            c && this.callback(this.manager, b, {pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a})
        }
    }), j(S, y, {
        handler: function (a, b, c) {
            var d = c.pointerType == tb, e = c.pointerType == vb;
            if (d)this.mouse.allow = !1; else if (e && !this.mouse.allow)return;
            b & (Ab | Bb) && (this.mouse.allow = !0), this.callback(a, b, c)
        }, destroy: function () {
            this.touch.destroy(), this.mouse.destroy()
        }
    });
    var Yb = v(jb.style, "touchAction"), Zb = Yb !== d, $b = "compute", _b = "auto", ac = "manipulation", bc = "none", cc = "pan-x", dc = "pan-y";
    T.prototype = {
        set: function (a) {
            a == $b && (a = this.compute()), Zb && (this.manager.element.style[Yb] = a), this.actions = a.toLowerCase().trim()
        }, update: function () {
            this.set(this.manager.options.touchAction)
        }, compute: function () {
            var a = [];
            return g(this.manager.recognizers, function (b) {
                l(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()))
            }), U(a.join(" "))
        }, preventDefaults: function (a) {
            if (!Zb) {
                var b = a.srcEvent, c = a.offsetDirection;
                if (this.manager.session.prevented)return void b.preventDefault();
                var d = this.actions, e = q(d, bc), f = q(d, dc), g = q(d, cc);
                return e || f && c & Hb || g && c & Ib ? this.preventSrc(b) : void 0
            }
        }, preventSrc: function (a) {
            this.manager.session.prevented = !0, a.preventDefault()
        }
    };
    var ec = 1, fc = 2, gc = 4, hc = 8, ic = hc, jc = 16, kc = 32;
    V.prototype = {
        defaults: {}, set: function (a) {
            return h(this.options, a), this.manager && this.manager.touchAction.update(), this
        }, recognizeWith: function (a) {
            if (f(a, "recognizeWith", this))return this;
            var b = this.simultaneous;
            return a = Y(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this
        }, dropRecognizeWith: function (a) {
            return f(a, "dropRecognizeWith", this) ? this : (a = Y(a, this), delete this.simultaneous[a.id], this)
        }, requireFailure: function (a) {
            if (f(a, "requireFailure", this))return this;
            var b = this.requireFail;
            return a = Y(a, this), -1 === s(b, a) && (b.push(a), a.requireFailure(this)), this
        }, dropRequireFailure: function (a) {
            if (f(a, "dropRequireFailure", this))return this;
            a = Y(a, this);
            var b = s(this.requireFail, a);
            return b > -1 && this.requireFail.splice(b, 1), this
        }, hasRequireFailures: function () {
            return this.requireFail.length > 0
        }, canRecognizeWith: function (a) {
            return !!this.simultaneous[a.id]
        }, emit: function (a) {
            function b(b) {
                c.manager.emit(c.options.event + (b ? W(d) : ""), a)
            }

            var c = this, d = this.state;
            hc > d && b(!0), b(), d >= hc && b(!0)
        }, tryEmit: function (a) {
            return this.canEmit() ? this.emit(a) : void(this.state = kc)
        }, canEmit: function () {
            for (var a = 0; a < this.requireFail.length;) {
                if (!(this.requireFail[a].state & (kc | ec)))return !1;
                a++
            }
            return !0
        }, recognize: function (a) {
            var b = h({}, a);
            return l(this.options.enable, [this, b]) ? (this.state & (ic | jc | kc) && (this.state = ec), this.state = this.process(b), void(this.state & (fc | gc | hc | jc) && this.tryEmit(b))) : (this.reset(), void(this.state = kc))
        }, process: function () {
        }, getTouchAction: function () {
        }, reset: function () {
        }
    }, j(Z, V, {
        defaults: {pointers: 1}, attrTest: function (a) {
            var b = this.options.pointers;
            return 0 === b || a.pointers.length === b
        }, process: function (a) {
            var b = this.state, c = a.eventType, d = b & (fc | gc), e = this.attrTest(a);
            return d && (c & Bb || !e) ? b | jc : d || e ? c & Ab ? b | hc : b & fc ? b | gc : fc : kc
        }
    }), j($, Z, {
        defaults: {event: "pan", threshold: 10, pointers: 1, direction: Jb}, getTouchAction: function () {
            var a = this.options.direction, b = [];
            return a & Hb && b.push(dc), a & Ib && b.push(cc), b
        }, directionTest: function (a) {
            var b = this.options, c = !0, d = a.distance, e = a.direction, f = a.deltaX, g = a.deltaY;
            return e & b.direction || (b.direction & Hb ? (e = 0 === f ? Cb : 0 > f ? Db : Eb, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Cb : 0 > g ? Fb : Gb, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction
        }, attrTest: function (a) {
            return Z.prototype.attrTest.call(this, a) && (this.state & fc || !(this.state & fc) && this.directionTest(a))
        }, emit: function (a) {
            this.pX = a.deltaX, this.pY = a.deltaY;
            var b = X(a.direction);
            b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a)
        }
    }), j(_, Z, {
        defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
            return [bc]
        }, attrTest: function (a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & fc)
        }, emit: function (a) {
            if (this._super.emit.call(this, a), 1 !== a.scale) {
                var b = a.scale < 1 ? "in" : "out";
                this.manager.emit(this.options.event + b, a)
            }
        }
    }), j(ab, V, {
        defaults: {event: "press", pointers: 1, time: 500, threshold: 5}, getTouchAction: function () {
            return [_b]
        }, process: function (a) {
            var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime > b.time;
            if (this._input = a, !d || !c || a.eventType & (Ab | Bb) && !f)this.reset(); else if (a.eventType & yb)this.reset(), this._timer = e(function () {
                this.state = ic, this.tryEmit()
            }, b.time, this); else if (a.eventType & Ab)return ic;
            return kc
        }, reset: function () {
            clearTimeout(this._timer)
        }, emit: function (a) {
            this.state === ic && (a && a.eventType & Ab ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = nb(), this.manager.emit(this.options.event, this._input)))
        }
    }), j(bb, Z, {
        defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
            return [bc]
        }, attrTest: function (a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & fc)
        }
    }), j(cb, Z, {
        defaults: {event: "swipe", threshold: 10, velocity: .65, direction: Hb | Ib, pointers: 1},
        getTouchAction: function () {
            return $.prototype.getTouchAction.call(this)
        },
        attrTest: function (a) {
            var b, c = this.options.direction;
            return c & (Hb | Ib) ? b = a.velocity : c & Hb ? b = a.velocityX : c & Ib && (b = a.velocityY), this._super.attrTest.call(this, a) && c & a.direction && a.distance > this.options.threshold && mb(b) > this.options.velocity && a.eventType & Ab
        },
        emit: function (a) {
            var b = X(a.direction);
            b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a)
        }
    }), j(db, V, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 2,
            posThreshold: 10
        }, getTouchAction: function () {
            return [ac]
        }, process: function (a) {
            var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime < b.time;
            if (this.reset(), a.eventType & yb && 0 === this.count)return this.failTimeout();
            if (d && f && c) {
                if (a.eventType != Ab)return this.failTimeout();
                var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0, h = !this.pCenter || I(this.pCenter, a.center) < b.posThreshold;
                this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;
                var i = this.count % b.taps;
                if (0 === i)return this.hasRequireFailures() ? (this._timer = e(function () {
                    this.state = ic, this.tryEmit()
                }, b.interval, this), fc) : ic
            }
            return kc
        }, failTimeout: function () {
            return this._timer = e(function () {
                this.state = kc
            }, this.options.interval, this), kc
        }, reset: function () {
            clearTimeout(this._timer)
        }, emit: function () {
            this.state == ic && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
        }
    }), eb.VERSION = "2.0.4", eb.defaults = {
        domEvents: !1,
        touchAction: $b,
        enable: !0,
        inputTarget: null,
        inputClass: null,
        preset: [[bb, {enable: !1}], [_, {enable: !1}, ["rotate"]], [cb, {direction: Hb}], [$, {direction: Hb}, ["swipe"]], [db], [db, {
            event: "doubletap",
            taps: 2
        }, ["tap"]], [ab]],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var lc = 1, mc = 2;
    fb.prototype = {
        set: function (a) {
            return h(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this
        }, stop: function (a) {
            this.session.stopped = a ? mc : lc
        }, recognize: function (a) {
            var b = this.session;
            if (!b.stopped) {
                this.touchAction.preventDefaults(a);
                var c, d = this.recognizers, e = b.curRecognizer;
                (!e || e && e.state & ic) && (e = b.curRecognizer = null);
                for (var f = 0; f < d.length;)c = d[f], b.stopped === mc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (fc | gc | hc) && (e = b.curRecognizer = c), f++
            }
        }, get: function (a) {
            if (a instanceof V)return a;
            for (var b = this.recognizers, c = 0; c < b.length; c++)if (b[c].options.event == a)return b[c];
            return null
        }, add: function (a) {
            if (f(a, "add", this))return this;
            var b = this.get(a.options.event);
            return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a
        }, remove: function (a) {
            if (f(a, "remove", this))return this;
            var b = this.recognizers;
            return a = this.get(a), b.splice(s(b, a), 1), this.touchAction.update(), this
        }, on: function (a, b) {
            var c = this.handlers;
            return g(r(a), function (a) {
                c[a] = c[a] || [], c[a].push(b)
            }), this
        }, off: function (a, b) {
            var c = this.handlers;
            return g(r(a), function (a) {
                b ? c[a].splice(s(c[a], b), 1) : delete c[a]
            }), this
        }, emit: function (a, b) {
            this.options.domEvents && hb(a, b);
            var c = this.handlers[a] && this.handlers[a].slice();
            if (c && c.length) {
                b.type = a, b.preventDefault = function () {
                    b.srcEvent.preventDefault()
                };
                for (var d = 0; d < c.length;)c[d](b), d++
            }
        }, destroy: function () {
            this.element && gb(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
        }
    }, h(eb, {
        INPUT_START: yb,
        INPUT_MOVE: zb,
        INPUT_END: Ab,
        INPUT_CANCEL: Bb,
        STATE_POSSIBLE: ec,
        STATE_BEGAN: fc,
        STATE_CHANGED: gc,
        STATE_ENDED: hc,
        STATE_RECOGNIZED: ic,
        STATE_CANCELLED: jc,
        STATE_FAILED: kc,
        DIRECTION_NONE: Cb,
        DIRECTION_LEFT: Db,
        DIRECTION_RIGHT: Eb,
        DIRECTION_UP: Fb,
        DIRECTION_DOWN: Gb,
        DIRECTION_HORIZONTAL: Hb,
        DIRECTION_VERTICAL: Ib,
        DIRECTION_ALL: Jb,
        Manager: fb,
        Input: y,
        TouchAction: T,
        TouchInput: Q,
        MouseInput: M,
        PointerEventInput: N,
        TouchMouseInput: S,
        SingleTouchInput: O,
        Recognizer: V,
        AttrRecognizer: Z,
        Tap: db,
        Pan: $,
        Swipe: cb,
        Pinch: _,
        Rotate: bb,
        Press: ab,
        on: n,
        off: o,
        each: g,
        merge: i,
        extend: h,
        inherit: j,
        bindFn: k,
        prefixed: v
    }), typeof define == kb && define.amd ? define(function () {
        return eb
    }) : "undefined" != typeof module && module.exports ? module.exports = eb : a[c] = eb
}(window, document, "Hammer");
